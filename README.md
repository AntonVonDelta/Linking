# Linking

For dlls this is how it goes at linker time:
 - IAT table is allocated for each imported dll. The space is just for plain 4 byte addresses. Each address will point to a dll function.
 - IAT is created in idata segment of the EXE not import library or dll. BUT dlls can import other dlls and then the 
      exe will have a IAT table and the dll also
 - Import library signals the linker that a DLL is referenced. SO import libraries are not just static libraries with perhaps code for the dll. 
 - Import libraries are treated specially by the linker. They contain some flag that notifies the linker a dll is referenced.
 - Import libraries DO NOT contain the stubs! They contain no code except for the symbols that the dll also exports.
 - The stubs are generated by the linker only for referenced dlls.
 
 - Each entry of the IAT is an address to the coresponding function of the loaded dll.
 - Of course initially these addresses are not populated. They are populated by the loader at runtime after the dll is loaded.
 
 - During the linking phase of the exe, the LINKER creates "stubs" for each function.
 - Each stub is a `jmp dword ptr [<absolute IAT address>]`. Absolute IAT address is known at compilation time.
 - This jump loads the address stored at <absolute IAT address> and jumps there.
 
 The compiler generates a `call <missing address>` instruction for all undefined functions it has found.
 - In the case of static libraries, the linker will fill the address of the function from the library after it adds the code to the exe.
 - But for dlls the address is not know at linking time. So a import lib is needed to 'shut' the linker up.
   - This library exports all the symbols corresponding to the exported functions by the dll.
   - The lib doen't actually have ANY code. It used to contains the stubs (https://stackoverflow.com/questions/22679420/indirect-jumps-for-dll-function-calls)
   - The linker generates stubs that it adds to the `text` segment. 
   - These stubs jump to the function in the dll.
However there's an indirection for the dll case. The jump is an overhead.
So to hint to the compiler that the undefined function is actually exported by a dll you use `declspec(dllimport)`. 
This allows the compiler to optimize and drop the `call <missing>` opcode in favor to calling directly into the 
IAT table like so `call dword ptr [<absolute IAT address>]`. 
This way no stub is needed or used.
Thus `dllimport` can be left out and the code will still work.

 
**Note:** You may actually notice that in code there are two jumps used instead of only the stub.
In code you will find `call <address1>` where `address1:  jmp <address2>` and `address2: jmp dword ptr [<address of IAT>]`
This is caused by incremental linking which is ON even in release.


## Bibliography
https://stackoverflow.com/questions/42295270/how-import-libraries-work-exactly)
https://docs.microsoft.com/en-us/archive/msdn-magazine/2002/march/inside-windows-an-in-depth-look-into-the-win32-portable-executable-file-format-part-2

```
If linked implicitly when the program is built, then stubs for each DLL export used by the program get linked in 
to the program from an import library, and those stubs get updated as the EXE and the DLL are loaded when the 
process launches. (Yes, I've simplified more than a little here...)

Those stubs need to come from somewhere, and in the Microsoft tool chain they come from a special form 
of .LIB file called an import library. The required .LIB is usually built at the same time as the DLL, 
and contains a stub for each function exported from the DLL.
(https://stackoverflow.com/questions/3573475/how-does-the-import-library-work-details)
```
  
```
Note: in the past, the linker did not explicitly generate jump stubs but took them from the import libraries.
They contained complete object files both the stubs and the structures necessary for generating the PE 
import directory.
(https://stackoverflow.com/questions/22679420/indirect-jumps-for-dll-function-calls)
```

https://blog.katastros.com/a?ID=00050-50781f47-49eb-429c-89f2-9f634669e6a0
